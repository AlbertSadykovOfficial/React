# Хуки

Хуки - это обособленные функциональные блоки.

Есть уже встроенные хуки, к примеру, ответвенные за
жизненный цикл приложения (useLayoutEffect, useEffect),
что соотносится с beforeMount и Mount во Vue

Написание компонет на хуках на React в целом соответсвует 
Composition API во Vue, но если во Vue функция, ответственная
за компонент (setup) вызывается 1 раз: только при инициализации,
то в React функция инициализации вызывается каждый раз при
рендеринге страницы.

## Виды хуков 

### Состояние:
__useState__ - хук, возвращющий переменную и метод для ее мутации
__useReducer__ - хук, который возвращает вторым параметром не
функцию мутации переменной, а функцию редуктор. Первым параметром
конструтор принимает функцию-редуктор, а вторым - начальное значение.
При вызове функции-редуктора можно передавать ей параметры.

Функция редуктор - принимает текущее состяние и возвращает новое,
т.е. функция берет на себя правильное изменение состояния (а потом,
похоже, сама мнимо вызывает функцию setState).

### Жизненный цикл компонента:
__useLayoutEffect__ - хук, вызываемый до рендеринга компоненты
__useEffect__ - хук, вызываемый после рендеринга компоненты 

### Производительность:
По умолчанию, так как функция инициализациии вызывается каждый
раз при рендеринге, то объявленные переменные обновляются, 
что побуждает вызов связных с ними функций (функций, где используются
эти переменные) - это неоптимизированно и есть способы увеличения
производительности.

__useMemo__ - хук, который мемоизирует переменную и вызывает связные 
с ней функции только в том случае, если состояние переменной при текущем 
рендеринге отличается от состояния переменной в предыдущем рендеринге 
(аналог computed - свойства во Vue), полуенная при создании переменная 
должна передаваться вторым парметром, к примеру, в useEffect.
__useCallback__ - это useMemo для функций.

#### Функция производительности для компонент: 
Компоненты как и переменные - без мемоизации будут вызывать конструктор
каждый раз при рендеринге, чтобы избежать этого нужно мемоизировать 
компонент, при этом стоит знать, что мемоизация для обычных типов данных
будет работать - как нужно, но если тип данных - объект (функция), который
передается по ссылке, то нужно использовать дополнительный параметр - функцию
с правилами рендеринга. 

__memo__ - функция для мемоизации чистых компонент, возвращает мемоизированный
компонент.

**Мемоизация для компонентов-функций:**
```js
  const PureCat = memo(Cat)
  const PureCat2 = memo(Cat, (prevProps, nextProps) => prevProps.name === nextProps.name)
```

**Мемоизация для компонентов-классов:**
Если компонет-класс выглядит так:
```js
  class Cat extends React.Component {
    render () {
      return {
        {name} is a good cat!
      }
    }
  }
```

PureComponent выглядит так:
```js
  class Cat extends React.PureComponent {
    render () {
      return {
        {name} is a good cat!
      }
    }
  }
```

## Понятие массива зависимостей
В связи с вызывом функции инициализации при каждом рендеринге,
каждая функция useEffect вызывается заново, так как React не может
знать какие данные связаны с этой функцией, возможно, там нужно 
что-то поменять. Чтобы функция не вызывалась, ей следует сообщить
при изменении каких переменных следует ее вызвать. На вход она 
ожидает массив перменных. Если ничего не указать - вызывается каждый
раз, если пустой массив - вызовется ОДИН раз при первом рендеринге,
если передать переменную - то только при изменении этой переменной.
Для корректного слежения за объектами следует мемоизировать их чрез
useMemo, иначе опять же при инициализации они создадутся заново и
ссылка на них изменится - а занчит функция useEffect вызовется

## Пользовательские хуки
Целью создания пользовательских хуков является декомпозиция
функционала и унификация. Если есть фрагменты, которые повторяются
или выглядят обособлено - их лучше выносить в отдельные хуки.